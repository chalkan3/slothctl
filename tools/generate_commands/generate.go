package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"os"
	"path/filepath"
	"strings"
)

const (
	projectRoot = "." // This will be the current working directory when `go generate` is run from project root
	commandsDir = "pkg/commands"
	outputDir   = "zz_generated_commands" // This is the directory relative to project root
	outputFile  = "zz_generated_commands.go"
)

func main() {
	wd, err := os.Getwd()
	if err != nil {
		log.Fatalf("Error getting current working directory: %v", err)
	}
	log.Printf("Current working directory: %s\n", wd)

	// The directory to scan for commands, relative to the project root
	scanDir := filepath.Join(wd, commandsDir)

	packages, err := findCommandPackages(scanDir, wd) // Pass project root for relative path calculation
	if err != nil {
		log.Fatalf("Error finding command packages: %v", err)
	}

	if err := generateCommandsFile(packages, wd); err != nil { // Pass project root for output file path
		log.Fatalf("Error generating commands file: %v", err)
	}

	fmt.Printf("Generated %s/%s with %d command packages.\n", outputDir, outputFile, len(packages))
}

// findCommandPackages scans the directory for packages that contain BluePrintCommand implementations.
// projectRoot is the absolute path to the project's root directory.
func findCommandPackages(dir string, projectRoot string) ([]string, error) {
	uniquePackages := make(map[string]bool)
	var packages []string
	err := filepath.Walk(dir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if !info.IsDir() {
			return nil
		}
		// Skip the root commands directory itself
		if path == dir {
			return nil
		}
		if strings.HasPrefix(info.Name(), ".") || strings.HasPrefix(info.Name(), "zz_") || info.Name() == "generate.go" {
			return filepath.SkipDir // Skip hidden directories, generated files, and generate.go
		}

		fset := token.NewFileSet()
		pkgs, err := parser.ParseDir(fset, path, nil, parser.ParseComments)
		if err != nil {
			if strings.Contains(err.Error(), "no buildable Go source files") {
				return nil
			}
			return fmt.Errorf("error parsing directory %s: %w", path, err)
		}

		for _, pkg := range pkgs {
			for _, file := range pkg.Files {
				for _, imp := range file.Imports {
					if imp.Path.Value == "\"slothctl/pkg/commands\"" {
						ast.Inspect(file, func(node ast.Node) bool {
							if callExpr, ok := node.(*ast.CallExpr); ok {
								if selExpr, ok := callExpr.Fun.(*ast.SelectorExpr); ok {
									if ident, ok := selExpr.X.(*ast.Ident); ok && ident.Name == "commands" {
										if selExpr.Sel.Name == "AddCommandToRegistry" {
											// Calculate relative path from the project root
											relPath, err := filepath.Rel(projectRoot, path)
											if err != nil {
												log.Printf("Error getting relative path for %s: %v", path, err)
												return false
											}
											if _, exists := uniquePackages[relPath]; !exists {
												uniquePackages[relPath] = true
												packages = append(packages, relPath)
											}
											return false
										}
									}
								}
							}
							return true
						})
					}
				}
			}
		}
		return nil
	})
	if err != nil {
		return nil, err
	}
	return packages, nil
}

// generateCommandsFile creates the zz_generated_commands.go file with blank imports.
// projectRoot is the absolute path to the project's root directory.
func generateCommandsFile(packages []string, projectRoot string) error {
	var imports []string
	for _, pkg := range packages {
		imports = append(imports, fmt.Sprintf("\t_ \"slothctl/%s\"", pkg)) // pkg is already relative to project root
	}

	// Ensure the output directory exists, relative to project root
	fullOutputDir := filepath.Join(projectRoot, outputDir) // Corrected: outputDir is relative to project root
	if err := os.MkdirAll(fullOutputDir, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	content := fmt.Sprintf(`// Code generated by go generate; DO NOT EDIT.\n// This file was generated by pkg/commands/generate.go\n\npackage zz_generated_commands\n\nimport (\n%s\n)\n`, strings.Join(imports, "\n"))

	fullFilePath := filepath.Join(fullOutputDir, outputFile)
	log.Printf("Attempting to write to: %s\n", fullFilePath)
	return os.WriteFile(fullFilePath, []byte(content), 0644)
}