package main

import (
	"fmt"
	"log"
	"os"
	"path/filepath"
	"strings"
)

const (
	projectRoot = "." // This will be the current working directory when `go generate` is run from project root
	commandsDir = "pkg/commands"
	outputDir   = "zz_generated_commands" // This is the directory relative to project root
	outputFile  = "zz_generated_commands.go"
)

func main() {
	wd, err := os.Getwd()
	if err != nil {
		log.Fatalf("Error getting current working directory: %v", err)
	}
	log.Printf("Current working directory: %s\n", wd)

	// The directory to scan for commands, relative to the project root
	scanDir := filepath.Join(wd, commandsDir)

	packages, err := findCommandPackages(scanDir, wd) // Pass project root for relative path calculation
	if err != nil {
		log.Fatalf("Error finding command packages: %v", err)
	}

	if err := generateCommandsFile(packages, wd); err != nil { // Pass project root for output file path
		log.Fatalf("Error generating commands file: %v", err)
	}

	fmt.Printf("Generated %s/%s with %d command packages.\n", outputDir, outputFile, len(packages))
}

// findCommandPackages scans the directory for packages that contain BluePrintCommand implementations.
// projectRoot is the absolute path to the project's root directory.
func findCommandPackages(dir string, projectRoot string) ([]string, error) {
	uniquePackages := make(map[string]bool)
	var packages []string
	err := filepath.Walk(dir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if info.IsDir() {
			// Skip hidden directories and generated directories
			if strings.HasPrefix(info.Name(), ".") || strings.HasPrefix(info.Name(), "zz_") {
				return filepath.SkipDir
			}
			return nil
		}

		// Only process .go files
		if filepath.Ext(path) != ".go" {
			return nil
		}

		// Skip generate.go itself
		if info.Name() == "generate.go" {
			return nil
		}

		content, err := os.ReadFile(path)
		if err != nil {
			return fmt.Errorf("failed to read file %s: %w", path, err)
		}

		if strings.Contains(string(content), "commands.AddCommandToRegistry") {
			relPath, err := filepath.Rel(projectRoot, filepath.Dir(path))
			if err != nil {
				log.Printf("Error getting relative path for %s: %v", path, err)
				return nil
			}
			if _, exists := uniquePackages[relPath]; !exists {
				uniquePackages[relPath] = true
				packages = append(packages, relPath)
			}
		}
		return nil
	})
	if err != nil {
		return nil, err
	}
	return packages, nil
}

// generateCommandsFile creates the zz_generated_commands.go file with blank imports.
// projectRoot is the absolute path to the project's root directory.
func generateCommandsFile(packages []string, projectRoot string) error {
	var imports []string
	for _, pkg := range packages {
		imports = append(imports, fmt.Sprintf("	_ \"github.com/chalkan3/slothctl/%s\"", pkg)) // pkg is already relative to project root
	}

	// Ensure the output directory exists, relative to project root
	fullOutputDir := filepath.Join(projectRoot, outputDir) // Corrected: outputDir is relative to project root
	if err := os.MkdirAll(fullOutputDir, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	content := fmt.Sprintf(`// Code generated by go generate; DO NOT EDIT.
// This file was generated by pkg/commands/generate.go

package zz_generated_commands

import (
%s
)
`, strings.Join(imports, "\n"))

	fullFilePath := filepath.Join(fullOutputDir, outputFile)
	log.Printf("Attempting to write to: %s\n", fullFilePath)
	return os.WriteFile(fullFilePath, []byte(content), 0644)
}